# -*- coding: utf-8 -*-
"""Estudo Dirigido.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10hvypZFwwu0sIZ5eVn32nXnoGqvpW5Ky
"""

import numpy as np
import matplotlib.pyplot as plt
from IPython.display import HTML
from matplotlib import animation, rc
import random

"""# Classe Labirinto

"""

class Labirinto:
  
  def __init__(self,dim=10):
    
    # Inicializando o labirinto. Nele, vamos considerar que todas as celulas sao paredes
    self.labirintoPlot    =  np.zeros((dim,dim,3), dtype=np.int64)
    self.labirintoArestas =  np.zeros((dim,dim), dtype=np.int64)
    self.dim = dim 

    # Selecionar uma celula parede do labirinto como ponto inicial. Com a selecao abaixo,
    # o labirinto sempre tera seu inicio no canto esquerdo do grafico
    posicaoInicial = np.random.randint(0, (dim-1))
    

    fronteira = []
    fronteira.append((posicaoInicial,0))
    dx = [ 0, 1, 0, -1] # Movimentacao de x
    dy = [-1, 0, 1,  0] # movimentacao de y

    while fronteira != []:
      # Transformar a celula (parede) do labirinto em uma celula valida
      (vx, vy) = fronteira[-1] # Selecionando o ultimo elemento da lista
      self.labirintoArestas[vx,vy] = 1
      
      # verificar se a celula (parede) possui somente um vizinho que nao seja parede
      # caso sim, podemos incluir ela como uma passagem.
      vizinhosNaoVisitados=[]

      # Consideramos que a celula tem vizinhos acima, abaixo a esquerda e a direita.
      # Para isso, utilizamos as listas dx e dy para determinar essas posicoes
      for i in range(4):
        nx = vx + dx[i]
        ny = vy + dy[i]

        if nx >=0 and nx < dim and ny >=0 and ny < dim:
          if self.labirintoArestas[nx, ny] == 0:
            
            confereVizinho=0
            for j in range(4):
              ex = nx + dx[j]
              ey = ny + dy[j]

              if ex >=0 and ex < dim and ey >=0 and ey < dim:
                if self.labirintoArestas[ex, ey] == 1:
                  confereVizinho +=1
            
            if confereVizinho == 1:
              vizinhosNaoVisitados.append(i)
      
      if len(vizinhosNaoVisitados) > 0:
        irPara= np.random.choice(vizinhosNaoVisitados)
        vx += dx[irPara]
        vy += dy[irPara]
        fronteira.append((vx,vy))
      else:
        fronteira.pop()
    
    # Ajustar a posicao final (considerando um ponto do lado direito do labirinto)
    encontrou= False
    while not encontrou:
      posicaoFinal = np.random.randint(0,(dim-1))
      if self.labirintoArestas[posicaoFinal, dim-1] ==1:
        encontrou=True
    

    # Colorir Labirinto
    self.labirintoPlot[:,:, 0] += 255* self.labirintoArestas
    self.labirintoPlot[:,:, 1] += 255* self.labirintoArestas
    self.labirintoPlot[:,:, 2] += 255* self.labirintoArestas

    # Colorir posicao inicial e final
    self.labirintoPlot[posicaoInicial,0,1] = 0
    self.labirintoPlot[posicaoInicial,0,2] = 0

    self.labirintoPlot[posicaoFinal,dim-1, 0] = 0
    self.labirintoPlot[posicaoFinal,dim-1, 1] = 0

    # Armazenar no objeto as posicoes inicial e final do labirinto
    self.posicaoInicial = (posicaoInicial,0)
    self.posicaoFinal = (posicaoFinal,dim-1)

  def getLabirintoPlot(self, posicoes=None, cores=(255,0,0)):
    if posicoes==None:
      return self.labirintoPlot

    resposta = self.labirintoPlot.copy()
    for t in posicoes:
      for camada in range(3):
        resposta[t[0],t[1],camada] = cores[camada]
    
    return resposta
  

  def getPosicaoInicio(self):
    return self.posicaoInicial


  def getDestino(self):
    return self.posicaoFinal

"""# Funções auxiliares. Serão utilizadas para exibição dos nós visitados no labirinto"""

def getVizinhos(celula, labirinto):
  vizinhos = []
  (x, y) = celula
  mX = [0, 1, 0, -1]
  mY = [-1, 0, 1, 0]
  for i in range(4):
    posX = x + mX[i]
    posY = y + mY[i]
    if validaPos(posX, posY, labirinto):
      if labirinto.labirintoArestas[posX, posY] == 1:
        vizinhos.append((posX, posY))

  return vizinhos


def validaPos(posX, posY, labirinto):
  if (posX < 0) or (posX > labirinto.dim-1):
    return False
  if (posY < 0) or (posY > labirinto.dim-1):
    return False

  return True


def selecionaCaminho(caminhos, labirinto):
  caminhoPercorrido = []
  ultimaCelula = labirinto.getDestino()
  (x, y) = ultimaCelula

  while (x, y) != labirinto.getPosicaoInicio():
    (x, y) = ultimaCelula
    caminhoPercorrido.insert(0, ultimaCelula)
    ultimaCelula = caminhos[x, y]

  return caminhoPercorrido


def montaHeuristica(labirinto):
  h = np.zeros((labirinto.dim, labirinto.dim))
  for i in range(labirinto.dim):
    for j in range(labirinto.dim):
      h[i, j] = distEuclidiana(labirinto, (i, j))

  return h


def distEuclidiana(labirinto, posAtual):
  (Xp1, Yp1) = labirinto.getPosicaoInicio()
  (Xp2, Yp2) = posAtual
  return ((((Xp2 - Xp1) ** 2) + (Yp2 - Yp1) ** 2) ** 0.5)
  

def ordenaVizinhosBest(fronteira, aux, esquerda, direita, h):
  if direita <= esquerda:
    return

  meio = (esquerda + direita) // 2  
  ordenaVizinhosBest(fronteira, aux, esquerda, meio, h) # Ordena a primeira metade do arranjo. 
  ordenaVizinhosBest(fronteira, aux, meio+1, direita, h) # Ordena a segunda metade do arranjo.
  mergeBest(fronteira, aux, esquerda, meio, direita, h) # Combina as duas metades ordenadas anteriormente.


def mergeBest(fronteira, aux, esquerda, meio, direita, h):
  for k in range(esquerda, direita + 1):
    aux[k] = fronteira[k]
  i = esquerda
  j = meio + 1
  for k in range(esquerda, direita + 1):
    if i > meio:
      fronteira[k] = aux[j]
      j += 1
    elif j > direita:
      fronteira[k] = aux[i]
      i += 1
    elif h[aux[j]] < h[aux[i]]:
      fronteira[k] = aux[j]
      j += 1
    else:
      fronteira[k] = aux[i]
      i += 1
  

def montaCusto(labirinto):
  custo = np.zeros((labirinto.dim, labirinto.dim))
  for i in range(labirinto.dim):
    for j in range(labirinto.dim):
      custo[i, j] = 1
      # custo[i, j] = random.randint(1, 10)

  return custo


def ordenaVizinhosA(fronteira, aux, esquerda, direita, h, custo):
  if direita <= esquerda:
    return

  meio = (esquerda + direita) // 2  
  ordenaVizinhosA(fronteira, aux, esquerda, meio, h, custo) # Ordena a primeira metade do arranjo. 
  ordenaVizinhosA(fronteira, aux, meio+1, direita, h, custo) # Ordena a segunda metade do arranjo.
  mergeA(fronteira, aux, esquerda, meio, direita, h, custo) # Combina as duas metades ordenadas anteriormente.


def mergeA(fronteira, aux, esquerda, meio, direita, h, custo):
  for k in range(esquerda, direita + 1):
    aux[k] = fronteira[k]
  i = esquerda
  j = meio + 1
  for k in range(esquerda, direita + 1):
    if i > meio:
      fronteira[k] = aux[j]
      j += 1
    elif j > direita:
      fronteira[k] = aux[i]
      i += 1
    elif (h[aux[j]] + custo[aux[j]]) < (h[aux[i]] + custo[aux[i]]):
      fronteira[k] = aux[j]
      j += 1
    else:
      fronteira[k] = aux[i]
      i += 1

"""# Definição dos algoritmos de busca

## Busca em largura
"""

def buscaEmLargura(labirinto):

  fronteira = [] # lista vazia
  caminhos = np.zeros((labirinto.dim, labirinto.dim), dtype=[('x', 'int'), ('y', 'int')])
  celulasVisitadas = []
  statusLabirinto = []

  fronteira.append(labirinto.getPosicaoInicio())

  while fronteira != []:
    # Imprime Fronteira
    statusLabirinto.append(labirinto.getLabirintoPlot(posicoes=fronteira, cores=(0,255,127)))
    celula = fronteira.pop(0) # Selecionando o primeiro elemento da lista
    celulasVisitadas.append(celula)
    
    if celula == labirinto.getDestino():
      print("Objetivo", celula, "encontrado")
      caminhoEncontrado = selecionaCaminho(caminhos, labirinto)
      print(caminhoEncontrado)
      statusLabirinto.append(labirinto.getLabirintoPlot(posicoes=caminhoEncontrado, cores=(0,0,255)))
      return statusLabirinto
    
    else:
      for vizinho in getVizinhos(celula, labirinto):
        if vizinho not in celulasVisitadas:
          fronteira.append(vizinho)
          (x, y) = celula
          (posX, posY) = vizinho
          caminhos[posX, posY] = (x, y) 
  
  print("Objetivo nao existente no grafo")

"""## Busca em profundidade"""

def buscaEmProfundidade(labirinto):
    fronteira = [] # lista vazia
    caminhos = np.zeros((labirinto.dim, labirinto.dim), dtype=[('x', 'int'), ('y', 'int')])
    celulasVisitadas = []
    statusLabirinto = []

    fronteira.append(labirinto.getPosicaoInicio())

    while fronteira != []:
        # Imprime Fronteira
        statusLabirinto.append(labirinto.getLabirintoPlot(posicoes=fronteira, cores=(0,255,127)))
        celula = fronteira.pop(-1) # Selecionando o último elemento da lista
        celulasVisitadas.append(celula)
    
        if celula == labirinto.getDestino():
            print("Objetivo", celula, "encontrado")
            caminhoEncontrado = selecionaCaminho(caminhos, labirinto)
            print(caminhoEncontrado)
            statusLabirinto.append(labirinto.getLabirintoPlot(posicoes=caminhoEncontrado, cores=(0,0,255)))
            return statusLabirinto
    
        else:
            for vizinho in getVizinhos(celula, labirinto):
                if vizinho not in celulasVisitadas:
                    fronteira.append(vizinho) 
                    (x, y) = celula
                    (posX, posY) = vizinho
                    caminhos[posX, posY] = (x, y)
                    
  
    print("Objetivo nao existente no grafo")

"""##Best first"""

def bestFirst(labirinto):
    fronteira = [] # lista vazia
    caminhos = np.zeros((labirinto.dim, labirinto.dim), dtype=[('x', 'int'), ('y', 'int')])
    celulasVisitadas = []
    statusLabirinto = []

    h = montaHeuristica(labirinto)

    fronteira.append(labirinto.getPosicaoInicio())

    while fronteira != []:
        # Imprime Fronteira
        statusLabirinto.append(labirinto.getLabirintoPlot(posicoes=fronteira, cores=(0,255,127)))
        aux = [0] * len(fronteira)
        ordenaVizinhosBest(fronteira, aux, 0, len(fronteira)-1, h) # Ordena a fronteira de acordo com suas heurísticas
        celula = fronteira.pop(0) # Selecionando o primeiro elemento da lista
        celulasVisitadas.append(celula)
    
        if celula == labirinto.getDestino():
            print("Objetivo", celula, "encontrado")
            caminhoEncontrado = selecionaCaminho(caminhos, labirinto)
            print(caminhoEncontrado)
            statusLabirinto.append(labirinto.getLabirintoPlot(posicoes=caminhoEncontrado, cores=(0,0,255)))
            return statusLabirinto
    
        else:
            for vizinho in getVizinhos(celula, labirinto):
                if vizinho not in celulasVisitadas:
                    fronteira.append(vizinho) 
                    (x, y) = celula
                    (posX, posY) = vizinho
                    caminhos[posX, posY] = (x, y)
                    
  
    print("Objetivo nao existente no grafo")

"""## A*"""

def aEstrela(labirinto):
  fronteira = [] # lista vazia
  caminhos = np.zeros((labirinto.dim, labirinto.dim), dtype=[('x', 'int'), ('y', 'int')])
  celulasVisitadas = []
  statusLabirinto = []

  h = montaHeuristica(labirinto)

  custo = montaCusto(labirinto)

  fronteira.append(labirinto.getPosicaoInicio())

  while fronteira != []:
      # Imprime Fronteira
      statusLabirinto.append(labirinto.getLabirintoPlot(posicoes=fronteira, cores=(0,255,127)))
      aux = [0] * len(fronteira)
      ordenaVizinhosA(fronteira, aux, 0, len(fronteira)-1, h, custo) # Ordena a fronteira de acordo com suas heurísticas e seus custos
      celula = fronteira.pop(0) # Selecionando o primeiro elemento da lista
      celulasVisitadas.append(celula)
  
      if celula == labirinto.getDestino():
          print("Objetivo", celula, "encontrado")
          caminhoEncontrado = selecionaCaminho(caminhos, labirinto)
          print(caminhoEncontrado)
          statusLabirinto.append(labirinto.getLabirintoPlot(posicoes=caminhoEncontrado, cores=(0,0,255)))
          return statusLabirinto
  
      else:
          for vizinho in getVizinhos(celula, labirinto):
              if vizinho not in celulasVisitadas:
                  fronteira.append(vizinho) 
                  (x, y) = celula
                  (posX, posY) = vizinho
                  caminhos[posX, posY] = (x, y)
                  

  print("Objetivo nao existente no grafo")

"""# Execução dos algoritmos de busca

## Criação do objeto labirinto (Escolha do tamanho e exibição do labirinto)
"""

# Podemos construir labirintos com diversas dimensoes (a ciratividade eh sua!)
labirinto = Labirinto(10) # Voces podem alterar a dimensao do labirinto (testei ate o tamanho 30). Caso aumente muito, vai ficar dificil de visualizar o resultado

fig = plt.figure(figsize=(10,10))
plt.imshow(labirinto.getLabirintoPlot())

"""## Busca em Largura"""

snapshots = buscaEmLargura(labirinto)

"""## Busca em profundidade"""

snapshots = buscaEmProfundidade(labirinto)

"""##Best first"""

snapshots = bestFirst(labirinto)

"""## A*

"""

snapshots = aEstrela(labirinto)

"""# Animando o labirinto
Podemos utilizar os labirintos retornados pelo algoritmo de busca para poder visualizar cada uma das iterações do algoritmo. No momento da busca, estão registrados tanto as fronteiras do algoritmo de busca quanto o resultado final encontrado. 
"""

# First set up the figure, the axis, and the plot element we want to animate
fig = plt.figure(figsize=(10,10))

# initialization function: plot the background of each frame
def init():
  a = labirinto.getLabirintoPlot()
  im = plt.imshow(a, interpolation='none', aspect='auto', vmin=0, vmax=1)
  return [im]


def animate_func(i):
  im = plt.imshow(snapshots[i], interpolation='none', aspect='auto', vmin=0, vmax=1)
  #im.set_array(snapshots[i])
  return [im]

anim = animation.FuncAnimation(fig,
                               animate_func,
                               init_func=init,
                               frames=len(snapshots), # Numero de frames para animacao
                               interval=100, # Intervalo entre cada frame (em milisegundos)
                               blit=True)
# Note: below is the part which makes it work on Colab
rc('animation', html='jshtml')
anim