# -*- coding: utf-8 -*-
"""Lista3_Novo_Student.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16DFIA49YHaGpQUHhp8fBcaG9o10O6dHp
"""

import numpy as np
from skimage import io, data, transform, filters, util, color
from scipy import ndimage, stats, fft
import matplotlib.pyplot as plt
import copy

def show(img_list, caption_list):
    n = len(img_list)
    f, ax = plt.subplots(1,n, figsize=(10+5*(n-1),10))
    for i in range(n):
        ax[i].imshow(img_list[i], cmap='gray')
        ax[i].set_title(caption_list[i])

"""# Questão 1
<p align="justify"> Modifique o código <i>NoiseSum</i> (disponível nos slides) que remove o ruído de $n$ imagens ruidosas através da média de todas as imagens. Modifique o código de forma tal que use a mediana no lugar da média. Para encontrar a mediana de um conjunto de elementos basta ordenar os dados e selecionar o elemento que se encontra na metade do conjunto de dados. Por exemplo, seja $A = [4, 6, 2, 9, 1, 3, 9]$, depois de ordenar o vetor fica da seguinte forma $[1, 2, 3, 4, 6, 9, 9]$. A mediana é igual a 4. Para ordenar um conjunto de elementos use a função <i>numpy.sort(dados, axis=- 1)</i>, onde <i>dados</i> são os elementos que vão ser ordenados e <i>axis</i> especifica em qual das dimensões da matriz vai ser realizada a ordenação dos dados, 0 ordenada por linhas, 1 por colunas e 2 por profundidade. Não é necessário salvar as imagens ruidosas que foram geradas na execução do código. </p>

<p align="justify">Logo, modifique o código usando a função <i>numpy.median(dados, axis)</i> para encontrar a imagem "mediana".</p>
"""

def NoiseSum(img, n):
    lin, col = img.shape[:2]
    figs = np.zeros((lin, col, n))
    for i in range(n):
      tmp = util.random_noise(img, 'gaussian')
      #Gera ruido na imagem, ruido gaussiano
      figs[:,:,i] = tmp
      #Adicionando o ruido na imagem
      
    figs_sort = np.sort(figs, axis = 2)
    nimg = figs_sort[:,:,int(n/2)]
    
    return figs, nimg

def colore(matches, mask_body, mask_head):
	inc = 0.1
	nimg = np.dstack((matches, matches, matches))
	n2img = util.img_as_float(nimg)
	x,y = matches.shape
	for i in range(x):
		for j in range(y):
			if(mask_body[i,j] != 0):
				n2img[i,j,0] += 2 * inc
				n2img[i,j,1] += 2 * inc
				n2img[i,j,2] += inc
			elif(mask_head[i,j] != 0):
				n2img[i,j,0] += 2 * inc
				n2img[i,j,1] += inc
				n2img[i,j,2] += inc
			else:
				n2img[i,j,0] += inc
				n2img[i,j,1] += inc
				n2img[i,j,2] += 2 * inc
	
	return n2img

#x,y = (2,2)
#k = 3
"""
for n in range(4):
	if(n == 0):
		for i in range(k): #iterar em linhas
			for j in range(k): #iterar em colunas
				acc[i,j] = img[(x - i), (y - j)]
	else if(n==1):
		for i in range(k): #iterar em linhas
			for j in range(k): #iterar em colunas
				acc[i,j] = img[(x - i), (y + j)]
	else if(n == 2):
		for i in range(k): #iterar em linhas
			for j in range(k): #iterar em colunas
				acc[i,j] = img[(x + i), (y - j)]
	else:
		for i in range(k): #iterar em linhas
			for j in range(k): #iterar em colunas
				acc[i,j] = img[(x + i), (y + j)]

"""
def kuwahara(k, ponto, img):
	x,y = ponto #coord do ponto a ser modificado
	acc = np.zeros((k,k)) #matriz que armazenara os valores dos quadrados k x k
	media = np.Inf #media do valor. Atribuicao aqui eh infinito
	dx = [ -1, -1, 1, 1] #vetor que indica as movimentacoes em X. Na primeira e segunda analise, ira subtrair do eixo x, na terceira e na quarta, incrementar
	dy = [-1, 1, -1,  1] #vetor que indica as movimentacoes em Y. Na primeira e terceira analise, ira subtrair do eixo y, na segunda e na quarta, incrementar
	for n in range(4): #pros quatro quadrantes
		for i in range(k): #iterar em linhas
			for j in range(k): #iterar em colunas
				acc[i,j] = img[(x + dx[n]*i), (y + dy[n]*j)] #coloca na matriz acc os valores correspondentes
		if(media > np.var(acc)): #verifica se a media atual eh maior que a do quadrante a ser analizado
			media = np.mean(acc) #Calcula a nova media e substitui
		acc = np.zeros((k,k)) #zerar matriz de armazenamento
	return media #retorna o novo valor do ponto, que eh a media do quadrante de menor variancia

nimg = np.array([[112.243, 107.226, 99.611, 90.921, 99.265], [117.66, 116.265, 109.265, 93.977, 90.88 ], [114.166, 104.938, 112.009, 114.781, 107.069], [136.226, 138.226, 123.215, 113.258, 98.127], [112.009, 114.65, 128.867, 139.981, 114.166]])
#print(img[2,2])
img = copy.deepcopy(nimg)
nimg[2,2] = kuwahara(3, (2,2), nimg)
print(img[2,2])
print(nimg[2,2])

show([img, nimg], ['img', 'nimg'])

def kuwahara(k, ponto, img):
	x,y = ponto #coord do ponto a ser modificado
	acc = np.zeros((k,k)) #matriz que armazenara os valores dos quadrados k x k
	variancia = np.Inf #media do valor. Atribuicao aqui eh infinito
	media = 0
	dx = [ -1, -1, 1, 1] #vetor que indica as movimentacoes em X. Na primeira e segunda analise, ira subtrair do eixo x, na terceira e na quarta, incrementar
	dy = [-1, 1, -1,  1] #vetor que indica as movimentacoes em Y. Na primeira e terceira analise, ira subtrair do eixo y, na segunda e na quarta, incrementar
	for n in range(4): #pros quatro quadrantes
		for i in range(k): #iterar em linhas
			for j in range(k): #iterar em colunas
				acc[i,j] = img[(x + dx[n]*i), (y + dy[n]*j)] #coloca na matriz acc os valores correspondentes
		nvar = np.var(acc)
		if(variancia > nvar): #verifica se a media atual eh maior que a do quadrante a ser analizado
			variancia = nvar
			media = np.mean(acc) #Calcula a nova media e substitui
		acc = np.zeros((k,k)) #zerar matriz de armazenamento
	return media, variancia #retorna o novo valor do ponto, que eh a media do quadrante de menor variancia

def TomatiETsuji(k, ponto, img):
	x,y = ponto
	media, variancia = kuwahara(k, ponto, img)
	quad = img[(x - k // 2): (x + k // 2), (y - k // 2): (y + k // 2)]
	nvar = np.var(quad)
	if(variancia > nvar):
		variancia = nvar
		media = np.mean(quad)
	return media, variancia


def compFiltragemBorda(Original):
	Kuwa = copy.deepcopy(Original)
	Tomaji = copy.deepcopy(Original)
	Kuwa[2,2], _ = kuwaharaTeste(3, (2,2), Kuwa)
	Tomaji[2,2], _ = TomatiETsujiTeste(3, (2,2), Tomaji)
	print(Original[2,2])
	print(Kuwa[2,2])
	print(Tomaji[2,2])
	show([Original, Kuwa, Tomaji], ['Original', 'Kuwahara', 'Tomaji'])

#Original = np.array([[112.243, 107.226, 99.611, 90.921, 99.265], [117.66, 116.265, 109.265, 93.977, 90.88 ], [114.166, 104.938, 112.009, 114.781, 107.069], [136.226, 138.226, 123.215, 113.258, 98.127], [112.009, 114.65, 128.867, 139.981, 114.166]])
#Original = np.array([[112.243, 107.226, 99.611, 90.921, 99.265], [112.243, 107.226, 99.611, 90.921, 99.265], [112.243, 107.226, 99.611, 90.921, 99.265], [112.243, 107.226, 99.611, 90.921, 99.265], [112.243, 107.226, 99.611, 90.921, 99.265]])
Original = np.array([[112.243, 107.226, 99.611, 90.921, 99.265], [117.66, 255, 255, 255, 90.88 ], [114.166, 255, 255, 255, 107.069], [136.226, 255, 255, 255, 98.127], [112.009, 114.65, 128.867, 139.981, 114.166]])
compFiltragemBorda(Original)

def kuwaharaTeste(k, ponto, img):
  x, y = ponto
  acc = np.zeros((k, k))
  variancia = 10000
  media = 0

  dx = [-1, -1, 1, 1]
  dy = [-1, 1, -1, 1]

  for n in range(4):
    for i in range(k):
      for j in range(k):
        acc[i, j] = img[(x + dx[n]*i), (y + dy[n]*j)]

    nvar = np.var(acc)
    if (variancia > nvar):
      variancia = nvar
      media = np.mean(acc)
    acc = np.zeros((k, k))
    
  return media, variancia
 

def TomatiETsujiTeste(k, ponto, img):
  x, y = ponto
  media, variancia = kuwaharaTeste(k, ponto, img)
  quad = img[(x - k // 2): (x + k // 2), (y - k // 2): (y + k // 2)]
  nvar = np.var(quad)
  if (variancia > nvar):
    variancia = nvar
    media = np.mean(quad)

  return media, variancia

lenna = io.imread('https://drive.google.com/uc?id=1k0FG4pT6WMjFeG-V63OBXNS7_CvfY5m_', as_gray=True)
figs, nimg = NoiseSum(lenna, 20)

show([figs[:,:,0], figs[:,:,1], nimg],['Imagem Ruido1', 'Imagem Ruido2', 'Imagem Filtrada'])

"""# Questão 2

<p align="justify">
O função <i>util.random_noise()</i> é utilizada para inserir ruído dentro de uma imagem. Entre os tipos de ruídos implementados está o ruido ``sal e pimenta'' (<i>mode = 's&p'</i>). Este tipo de ruído adiciona pontos brancos e pretos dentro da imagem. Adicione ruído sal e pimenta em uma imagem e remova o ruído inserido utilizando os métodos da mediana e minmax. Logo, compare as imagens resultantes com a imagem original utilizando o erro médio quadrático normalizado.
</p>
"""

def filtros_median_minmax(noise_img):
  """
  Entrada:
  - noise_img: imagem ruidosa

  Saída
  - img_median: imagem filtrada com o filtro da mediana
  - img_min_max: imagem filtrada com o filtro MIN MAX
  """  
  img_median = filters.rank.median(noise_img)
  footprint = np.ones( (3,3) )
  img_min_max = filters.rank.maximum(noise_img, footprint)
  img_min_max = filters.rank.minimum(img_min_max, footprint)

  return img_median, img_min_max

def NMSE(f, g):
  """
  Entrada:
  - f, g: imagens a ser comparadas

  Saída
  - error: erro mínimo quadrático normalizado
  """  
  f = util.img_as_float(f)
  g = util.img_as_float(g)
  error = np.sum((f - g)**2) / np.sum((f**2))
  
  return error

  #Calcula o erro médio quadrático normalizado
  #O quão distante as imagens estão uma da outra

lenna = io.imread('https://drive.google.com/uc?id=1k0FG4pT6WMjFeG-V63OBXNS7_CvfY5m_', as_gray=True)
noise_img = util.img_as_ubyte( util.random_noise(lenna, mode='s&p') )
img_median, img_min_max = filtros_median_minmax(noise_img)

f, ax = plt.subplots(1, 3, figsize=(16,16))
ax[0].imshow(noise_img, cmap='gray')
ax[1].imshow(img_median, cmap='gray')
ax[2].imshow(img_min_max, cmap='gray')

print(f'Erro médio quadrátivo normalizado entre lenna e mediana {NMSE(lenna, img_median)}')
print(f'Erro médio quadrátivo normalizado entre lenna e MINMAX {NMSE(lenna, img_min_max)}')

clown = io.imread('https://drive.google.com/uc?id=1JIiGsypcTefhq1s1Hk9fQIks8GE5KbuK', as_gray=True)
print(f'Erro médio quadrátivo normalizado lenna e palhaço: {NMSE(lenna, clown)}')

"""# Questão 3

<p align="justify">
Dada a seguinte imagem, eliminar o ruído produzido pelo ruído periódico. Teste com os seguinte filtros: média, mediana e a filtragem no domínio da frequência. Para o caso da filtragem no domínio da frequência, primeiro calcule o espectro de Fourier (segunda Figura) e elimine a <b>região</b> ao redor dos ``spikes'' (assinalados com a seta vermelha). Os ``spikes'' estão localizados nas coordenadas (88,88) e (170,170). A terceira imagem mostra o processo depois de apagar esses valores.
Para apagar os valores, basta atribuir zero para todos os elementos da região.
</p>

<table><tr>
<td> <img src="https://drive.google.com/uc?id=1ExhUVoHaj2i4gN1UWC6U7RfP-boZhnRL" alt="Drawing"  width="300"/> </td>
<td> <img src="https://drive.google.com/uc?id=1BGJbV6sXNNlt2PmIZ7RCyHpQfPRpZgJ6" alt="Drawing"  width="300"/> </td>
<td> <img src="https://drive.google.com/uc?id=1d3bAvzHJ5wRwPxIXGZXiUhP7bA5o0SbY" alt="Drawing"  width="300"/> </td>
</tr></table>
"""

def filtragem(img, window_size=5, coord1=(88,88), coord2=(170,170)):
  """
  Entrada:
  - img: imagem
  - window_size: tamanho da janela que será apagada
  - coord1: tupla com as coordenadas do primeiro spike
  - coord2: tupla com as coordenadas do segundo spike

  Saída
  - nimg: imagem filtrada
  - fimg: coeficiente de Fourier com as janelas ao redor do spike apagadas
  """  
  fimg = fft.fftshift(fft.fft2(img))
  fimg[coord1[0] - window_size: coord1[0] + window_size, coord1[1] - window_size: coord1[1] + window_size] = 0
  fimg[coord2[0] - window_size: coord2[0] + window_size, coord2[1] - window_size: coord2[1] + window_size] = 0
  nimg = fft.ifft2(fimg)
  nimg = np.abs(nimg)
  
  return nimg, fimg

lenna = io.imread('https://drive.google.com/uc?id=1ExhUVoHaj2i4gN1UWC6U7RfP-boZhnRL', as_gray=True)
nimg, fimg = filtragem(lenna, window_size=10)

show([lenna, np.log(np.abs(fimg)+1), nimg], ['Original', 'Espectro de Fourier','Imagem filtrada'])

"""#  Questão 4

<p align="justify">
Dada a seguinte imagem, eliminar o ruído produzido pelo ruído periódico da questão 3. Teste com os filtros passa-banda: Ideal e Gaussiano. Os ``spikes'' estão localizados nas coordenadas (88,88) e (170,170). 
</p>
"""

def gridFourier(M, N):
    u = np.arange(0, M)
    v = np.arange(0, N)
 
    u = u - np.floor(M/2)
    v = v - np.floor(N/2)
    U, V = np.meshgrid(u, v)
    
    return U, V

def mask_ideal_band(width, height, d0, W):
    """
    Entrada:
    - width: largura da máscara
    - height: altura da máscara
    - d0: raio
    - W: largura da banda

    Saída
    - H: máscara passa-banda ideal
    """

    U, V = gridFourier(width, height)
    D = np.sqrt(U**2 + V**2)
    if((d0 - W/2 <= D).all() and (D <= d0 + W/2).all()):
      H = 0
    else:
      H = 1    
    return H

def mask_gaussian_band(width, height, d0, W):
    """
    Entrada:
    - width: largura da máscara
    - height: altura da máscara
    - d0: raio
    - W: largura da banda

    Saída
    - H: máscara passa-banda Gaussiano
    """ 

    e = 2.718
    U, V = gridFourier(width, height)
    D = np.sqrt(U**2+V**2)
    H = 1-e**-(((D**2-d0**2)/(D*W))**2)

    return H

def passa_freq(img, mask):
    """
    Entrada:
    - img: imagem
    - mask: máscara

    Saída
    - nimg: imagem filtrada 
    - fimg: espectro de Fourier da imagem filtrada
    """ 

    height, width = img.shape[:2]
    fimg = fft.fftshift( fft.fft2(img) )
    fimg = fimg * mask
    nimg = fft.ifft2(fimg)
    nimg = np.abs(nimg)

    return nimg, fimg

lenna = io.imread('https://drive.google.com/uc?id=1ExhUVoHaj2i4gN1UWC6U7RfP-boZhnRL', as_gray=True)
lin, col = lenna.shape[:2]
HN = mask_ideal_band(col, lin, 58, 20)
nimg, fimg = passa_freq(lenna, HN)

show([lenna, np.log(np.abs(fimg)+1), nimg], ['Original','Filtro Notch', 'IMagem FIltrada'])

lenna = io.imread('https://drive.google.com/uc?id=1ExhUVoHaj2i4gN1UWC6U7RfP-boZhnRL', as_gray=True)
lin, col = lenna.shape[:2]
HN = mask_gaussian_band(col, lin, 58, 20)
nimg, fimg = passa_freq(lenna, HN)

show([lenna, np.log(np.abs(fimg)+1), nimg], ['Original','Filtro Notch', 'IMagem FIltrada'])