# -*- coding: utf-8 -*-
"""Lista1_2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dXxzlZdTICkgpomzG23sBcHOTi8DhYJh

# Questão 1: Numpy

### Importando bibliotecas Numpy, Skimage e Matplotlib
"""

import numpy as np
from skimage import io, data, transform
import matplotlib.pyplot as plt

"""#### 1.1 Dado $x = [1, 2, 3, 4, 5, 6]$, escreva esse vetor em Python e entenda o significado dos comandos abaixo:


1. print(x[5])
2. print(x[1:4])
3. print(x[1:])
4. print(x[1:-1])
5. print(x[5:1:-1])
6. print(x[[1,5,2,1,1]])



"""

x = np.array([1,2,3,4,5,6])
print(x[5])
print(x[1:4])
print(x[1:])
print(x[1:-1])
print(x[5:1:-1])
print(x[[1,5,2,1,1]])

"""#### 1.2 Considere a matriz M = [[10, 2, 10, 5], [2, 5, 1, 6], [2, 4, 8, 10],[4, 10, 3, 5]]. Substitua os valores da primeira coluna e da última linha por 1."""

M = np.array([[10, 2, 10, 5], [2, 5, 1, 6], [2, 4, 8, 10],[4, 10, 3, 5]])
M[:, 0] = 1
M[-1, :] = 1

print(M)

"""#### 1.3 Dada a matriz
$$ A = \left (
\begin{array}{ccccccc}
  2 & 10 & 7 & 6 \\
  3 & 12 & 25 & 9\\
\end{array}
\right )
$$


1.  Acrescente uma terceira linha a matriz com os elementos $[30, 21, 19, 1]$. 
$$ A = \left (
\begin{array}{ccccccc}
  2 & 10 & 7 & 6 \\
  3 & 12 & 25 & 9\\
  31 & 21 & 19 & 1
\end{array}
\right )
$$
2.  Crie a matriz $B$ gerada a partir da segunda a terceira linha, e da segunda a quarta coluna da matriz $A$ modificada
$$ B = \left (
\begin{array}{ccccccc}
  12 & 25 & 9\\
  21 & 19& 1 \\
\end{array}
\right )
$$




"""

#1 .
A = np.array([[2, 10, 7, 6], [3, 12, 25, 9]])
linha_add = np.array([30, 21, 19, 1])
resultA = np.vstack ((A, linha_add) )
#print(resultA)

#2.
B = resultA[1:4, 1:4]
print(B)

"""#### 1.3 Criar um vetor com componentes ímpares entre 31 e 75. $$V = [31,33,35,...,75]$$"""

vetor = np.array([])

for i in range(31, 76, 2):
  vetor = np.append(vetor, i)

print(vetor)

"""# Questão 2

#### 2.1 Converta uma imagem colorida para tons de cinza (luminância). Uma imagem em tons de cinza pode ser obtida a partir de uma imagem colorida aplicando-se a seguinte fórmula para cada um dos pixels da imagem original:  $L=0.299∗R+0.587∗G+0.114∗B$ , onde  $R$ ,  $G$  e  $B$  são as componentes de cor do pixel original.
"""

def rgb_to_gray(img):
  nimg = img[:, :, 0] * 0.299 + img[:, :, 1] * 0.587 + img[:, :, 2] * 0.114
  return nimg

img = data.chelsea()
nimg = rgb_to_gray(img)
plt.subplot(1, 2, 1)
plt.imshow(img)
plt.subplot(1, 2, 2)
plt.imshow(nimg, cmap='gray')

"""#### 2.2 Dada uma imagem, primeiro espelhar a imagem na vertical. Depois, a partir da imagem espelhada, espelhar novamente a mesma, mas na horizontal.  Não utilizar as funções *numpy.fliplr()* e *numpy.flipud()*. Faça uso de vetores para acessar os índices.

<table><tr>
<td> <img src="https://drive.google.com/uc?id=1k0FG4pT6WMjFeG-V63OBXNS7_CvfY5m_" alt="Drawing" style="width: 250px;"/> </td>
<td> <img src="https://drive.google.com/uc?id=1tKTbbMTRAUmewAEtvYb4cw2EPXnlfWug" alt="Drawing" style="width: 250px;"/> </td>
<td> <img src="https://drive.google.com/uc?id=1_BhbR_eQlJGJAHv1aviIQ-WaP_5AO3N0" alt="Drawing" style="width: 250px;"/> </td>
</tr></table>
"""

def minha_fliplr(img):
  nimg = img[:, -1::-1]
  return nimg

def minha_flipud(img):
  nimg = img[-1::-1, :]
  return nimg

nimg = minha_fliplr(img)
nimg2 = minha_flipud(nimg)
f, ax = plt.subplots(1,3, figsize=(25,25))
ax[0].imshow(img)
ax[1].imshow(nimg)
ax[2].imshow(nimg2)