# -*- coding: utf-8 -*-
"""Lista2_Novo_Student.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Bm7pA4w88_8uZKitw8bKX1Soo-chFwDJ
"""

import numpy as np
from skimage import io, data, transform, filters, util, color, util, exposure
import matplotlib.pyplot as plt
from scipy import ndimage

def show(img_list, caption_list, Axis=False):
    n = len(img_list)
    f, ax = plt.subplots(1,n, figsize=(10+5*(n-1),10))
    for i in range(n):
        ax[i].imshow(img_list[i], cmap='gray')
        ax[i].set_title(caption_list[i])
        if not Axis:
            ax[i].set_axis_off()

def mapping(img):
    nimg = util.img_as_float(img)
    mmin = np.min(nimg)
    nimg = nimg - mmin
    mmax = np.max(nimg)
    return nimg/mmax

"""# Questão 1
<p> Converta uma imagem colorida para tons de cinza (luminância). Uma imagem em tons de cinza pode ser obtida a partir de uma imagem colorida aplicando-se a seguinte fórmula para cada um dos pixels da imagem original: $L = 0.299*R + 0.587*G + 0.114*B$, onde $R$, $G$ e $B$ são as componentes de cor do pixel original. </p>
"""

def grayscale(img):
  nimg = np.dot(img[:, :, :], [0.299, 0.587, 0.114])
  return nimg

img = data.chelsea()
nimg = grayscale(img)
show([img, nimg], ['Colorida', 'Cinza'])

"""# Questão 2

<p>Testar as funções de transformação geométrica: 
rotação, escala, translação, cisalhamento em imagens. 

*   rotação: *transform.rotate(...)*
*   escala: *transform.rescale(...)*
*   traslação: *transform.AffineTransform(...)* e *transform.warp(..)*
*   cisalhamento: *transform.AffineTransform(...)* e *transform.warp(..)*

<ol>
  <li> <b>skimage.transform.rotate</b>(image, angle, resize=False, center=None, order=None, mode='constant', cval=0, clip=True, preserve_range=False): 
  Rotate image by a certain angle around its center.
      
  Parameters
  <ul>
  <li> image: ndarray. Input image.</li>
  <li> angle: float. Rotation angle in degrees in counter-clockwise direction.</li>
  <li> resize: bool, optional. Determine whether the shape of the output image will be automatically calculated, so the complete rotated image exactly fits. Default is False. </li>
  <li> center: iterable of length 2. The rotation center. If center=None, the image is rotated around its center, i.e. center=(cols / 2 - 0.5, rows / 2 - 0.5). Please note that this parameter is (cols, rows), contrary to normal skimage ordering. </li>
  </ul>
  Result
  <ul> 
  <li> rotated: ndarray. Rotated version of the input.</li>
  </ul> 
      
  <li> <b>skimage.transform.rescale</b>(image, scale, channel_axis=None): Scale image by a certain factor.
      
  Parameters
    <ul>
    <li> image: ndarray. Input image.</li>
    <li> scale: {float, tuple of floats}. Scale factors. S</li>
    <li> channel_axis: int or None, optional. If None, the image is assumed to be a grayscale (single channel) image. Otherwise, this parameter indicates which axis of the array corresponds to channels </li>
    </ul>
  Result
    <ul> 
    <li> rotated: ndarray. Scaled version of the input.</li>
    </ul> 

  <li><b>skimage.transform.AffineTransform</b>(matrix=None, scale=None, rotation=None, shear=None, translation=None, dimensionality=2)</li>
    
  Parameters
  <ul>
  <li> matrix: (D+1, D+1) array, optional. Homogeneous transformation matrix. </li>
  <li> scale: {s as float or (sx, sy) as array, list or tuple}, optional.  Scale factor(s). </li>
  <li> rotation: float, optional. Rotation angle in counter-clockwise direction as radians. Only available for 2D.</li>
  <li> shear: float, optional. Shear angle in counter-clockwise direction as radians. Only available for 2D.</li>
  <li> translation: (tx, ty) as array, list or tuple, optional. Translation parameters. Only available for 2D.</li>
  </ul>

  <li><b> skimage.transform.warp</b>(image, inverse_map, map_args={}, output_shape=None, order=None, mode='constant', cval=0.0, clip=True, preserve_range=False): Warp an image according to a given coordinate transformation.</li>
    
  Parameters
  <ul>
  <li> image: ndarray. Input image. </li>
  <li> inverse_map: transformation object. Inverse coordinate map, which transforms coordinates in the output images into their corresponding coordinates in the input image. </li>
  <li> map_args: dict, optional. Keyword arguments passed to inverse_map.</li>
  <li> output_shape: tuple (rows, cols), optional. Shape of the output image generated. By default the shape of the input image is preserved. </li>
  <li> order: int, optional. The order of interpolation. The order has to be in the range 0-5: (0: Nearest-neighbor, 1: Bi-linear (default), 2: Bi-quadratic, 3: Bi-cubic, 4: Bi-quartic, 5: Bi-quintic)</li>
  </ul> 
  Result
  <ul> 
  <li> warped: double ndarray. The warped input image.</li>
  </ul>   
</ol>
</p>
"""

rotacao = transform.rotate(img, 45)
escala = transform.rescale(img, scale = (2, 2, 1))
matriz_traslacao = transform.AffineTransform(translation=(50, 25))
traslacao = transform.warp(img, matriz_traslacao)
matriz_shear = transform.AffineTransform(shear = 0.7)
shear =  transform.warp(img, matriz_shear)

f, ax = plt.subplots(2,2, figsize=(10,10))
ax[0,0].imshow(rotacao)
ax[0,1].imshow(escala)
ax[1,0].imshow(traslacao)
ax[1,1].imshow(shear)

"""# Questão 3

<p>Calcule o histograma da seguinte imagem. </p>


<center>
<img src="https://drive.google.com/uc?id=1Tils6Uo-h2fh3JoTcsaMexoKR1AaMXqb" alt="Drawing" style="width: 250px;"/>
</center>

<p>
<b>scipy.ndimage.histogram</b>(input, min, max, bins): Calculate the histogram of the values of an array, optionally at labels.
<ul>
<li> input: array_like. Data for which to calculate histogram.</li>
<li> min, max: int. Minimum and maximum values of range of histogram bins.</li>
<li> bins: int. Number of bins.</li>
</ul>
</p>

<p>
Através dele poderá obversar que as intensidades estão concentradas na metade da escala de intensidades, não sendo possível distinguir claramente os detalhes da imagem. Corrija esse problema por meio das seguintes funções radiométricas.

1.   Use a função *exposure.adjust_gamma()*.

  **skimage.exposure.adjust_gamma**(image, gamma=1, gain=1): Performs Gamma Correction on the input image. Also known as Power Law Transform. This function transforms the input image pixelwise according to the equation O = I**gamma after scaling each pixel to the range 0 to 1.
  <ul>
  <li> image: ndarray. Input image.</li>
  <li> gamma: float, optional. Non negative real number. Default value is 1.</li>
  <li> gain: float, optional. The constant multiplier. Default value is 1.</li>
  </ul>
Returns
  <ul>
  <li> out: ndarray. Gamma corrected output image</li>
  </ul>

2.   Função *contrast-stretching* $$s = T(r) = \frac{1}{1 + (m/r)^E}$$ onde $r$ denota a intensidade da imagem, $m$ é um valor dentro do intervalo [0,1] e $E$ um valor positivo.

<center>
<img src="https://drive.google.com/uc?id=1hPgC1WDTmuU8A2E6AeEXPmanf_vW81_a" alt="Drawing" width="230" />
</center>

3. Tranformação *Power-law* (também conhecida como função *Gamma*)
    $$s = cr^\lambda$$ onde $c$ e $\lambda$ são constantes positivas, e $r$ é a intensidade da imagem.
<center>
<img src="https://drive.google.com/uc?id=16lffZmhq9mzzQ57haDY_zi1EOSwPELJo" alt="Drawing" width="300" class="center"/>
</center>
</p>
"""

img2 = io.imread("https://drive.google.com/uc?id=1Tils6Uo-h2fh3JoTcsaMexoKR1AaMXqb")
plt.imshow(img2, cmap='gray', vmin =0, vmax=255)

hist = ndimage.histogram(img2, 0, 255, 256)
plt.figure()
plt.plot(hist)

"""3.1 Usar a função exposure.adjust_gamma"""

nimg = exposure.adjust_gamma(nimg, gamma=1, gain=1)
plt.imshow(nimg, cmap='gray')

"""### 3.2.a Implementar o código para graficar a função *contrast streaching*

<center>
<img src="https://drive.google.com/uc?id=1hPgC1WDTmuU8A2E6AeEXPmanf_vW81_a" alt="Drawing" width="230" />
</center>
"""

np.seterr(divide='ignore', invalid='ignore')

def constrast_streching_function(m, E):
    f = 1 / (1+(m/np.arange(0, 1, 0.01))**E)
    return f

f = constrast_streching_function(m = 0.5, E = 10)

plt.plot(f)

"""## 3.2 Implementar código que permita aplicar a função *constrast streaching* em imagens"""

def constrast_streaching(img, m=0.5, E=2):
    fimg = util.img_as_float(img)
    nimg = 1 / (1+(m/fimg)**E)
    return nimg

nimg = constrast_streaching(img2, m=0.5, E=9)
plt.imshow(nimg, cmap='gray', vmin=0, vmax=1)

h2 = ndimage.histogram(nimg, min=0, max=1, bins=256)
plt.figure()
plt.plot(h2)

"""# Questão 4
## Mudar a cor do fundo (*background*) da imagem apresentada a continuação, ela deve estar em tons de azul claro. Além disso, é fornecido a imagem binária, onde os fósforos estão representados pela cor branca e o fundo pela cor preta. Use operações aritméticas para executar o processo de modificação do fundo. A continuação são mostradas a imagem em escala de cinza e a respectiva máscara.


<table><tr>
<td> 
<figure><img src="https://drive.google.com/uc?id=1V3OaLUh34dRCx-53PGsUYOMb1kZ1gqzo" alt="Drawing" width="300" class="center"/> 
<figcaption>Imagem em escala de cinza</figcaption>
</figure>
</td>
<td> 
<figure>
<img src="https://drive.google.com/uc?id=13NOF3oDNkmNtHCHmbX_9d0-AISPEmGZe" alt="Drawing" width="300" class="center"/> 
<figcaption>Máscara</figcaption>
</figure>
</td>
</tr>
</table>


##DICA: para conseguir modificar a intensidade do fundo, incremente um valor $inc$ nos canais vermelho e verde, e incremente um valor $2*inc$ no canal azul. Preserve as intensidades originais dos fósforos.   

##A Figura a continuação mostra o resultado final. A imagem gerada deve ser colorida e o tecido (fundo da imagem) deve aparecer na cor azul claro. 

<center>
<figure>
<img src="https://drive.google.com/uc?id=1vGfZccYEdWi1wLmKXow6rqgyF2phkXSA" alt="Drawing" width="300" class="center"/> 
<figcaption>Imágem resultante</figcaption>
</figure>
</center>


"""

def change_background(img, mask):
  nimg = np.dstack((img,img,img))
  fimg = util.img_as_float(nimg)
  for i in range(fimg.shape[0]):
    for j in range(fimg.shape[1]):
      if(mask[i,j] == 0):
        fimg[i,j,0] += 0.1
        fimg[i,j,1] += 0.1
        fimg[i,j,2] += 0.2
  return fimg

img = io.imread('https://drive.google.com/uc?id=1V3OaLUh34dRCx-53PGsUYOMb1kZ1gqzo')
mask = io.imread('https://drive.google.com/uc?id=13NOF3oDNkmNtHCHmbX_9d0-AISPEmGZe')
nimg = change_background(img, mask)
print(nimg.shape)
plt.imshow(nimg)