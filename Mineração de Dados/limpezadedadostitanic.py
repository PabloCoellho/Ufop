# -*- coding: utf-8 -*-
"""LimpezaDeDadosTitanic.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1M-xNcmnB137x9tyhqn9aob8MBd1NSNhU

#Limpeza de dados e transformação do desafio do titanic
O desafio do Kaggle pode ser encontrado no seguinte link: https://www.kaggle.com/c/titanic

Inicialmente será feita uma análise descritiva do desafio:

#Análise descritiva

# a) Identifique os tipos de atributos (contínuos , discretos, binários (simétricos ou assimétricos), categóricos (nominais ou ordinais)). Esta classificação deve ser feita e explicada manualmente.

*   PassengerId: representa um número único que identifica o passageiro no titanic, ele é um atributo **discreto** pois representa uma categoria específica.
*   Survived: representa se o passageiro morreu (1) ou não (0), é uma variável **binária simétrica**, binária pois pode assumir apenas dois valores e simétrica por não possuir hierarquia entre os dois.
*   Pclass: Representa em qual classe econômica estava o passageiro, podendo assumir 3 valores, 1st, 2nd e 3rd ou 1, 2, 3. Representa um atributo **categórico ordinal**, categórico pois rotula em diferentes classes e ordinal por haver hierarquia entre os dados.
*   Name: Nome do tripulante, **categórico nominal** pois rotula uma pessoa mas sem distinção de hierarquia entre seus pares, apenas nomeia.
*   Sex: Sexo do tripulante, podendo ser masulino ou feminino, ele se torna um atributo **binário simétrico**, pois pode assumir dois valores, sem hierarquia entre eles.
* Age: Idade do tripulante, atributo **contínuo** pois pode assumir qualquer valor em um range conhecido de números reais.
* SibSp: Quantidade de parentes, irmãos ou cônjuges abordo, é um atributo **discreto** valor contável e distinto de números inteiros não negativos.
* Parch: Funciona como o anterior mas com o número de pais / filhos abordo, ou seja, **discreto** 
* Ticket: Número do ticket do passageiro, sem distinção pelo valor, apenas categoriza, **categórico nominal**.
* Fare: tarifa paga pelo passageiro, atributo **contínuo** pois tem uma escala de medida em um range de valores reais.
* Cabin: Número da cabine do passageiro, apenas rotula sem hierarquizar, então é considerado **categórico nominal**.
* Embarked: Representa o porto de embarque do passageiro. Esse atributo é um exemplo de atributo **categórico nominal**, pois os valores possíveis são categorias distintas sem uma ordem específica.

#b) Para atributo numérico, identifique qual o seu intervalo de valores, valor médio, máximo, mínimo, desvio-padrão e valores aberrantes. Use funcões do dataframe para isso (por exemplo, describe, mean, sum ,...). Faça gráficos estilo boxplots para visualizar os possíveis outliers. Comente os resultados.

Inicialmente quais atributos numéricos serão levados em consideração?
O passenger ID, ticket e a Cabin, embora sejam numéricos, os valores não representam nada, nenhuma informação seria tirada da análise dos seus valores, assim como saber o valor míninmo, máximo e etc do Survived, tendo isso em vista será feita a análise do: **Pclass, Age, SibSp, Parch e Fare.**
"""

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
from scipy.stats import zscore
from sklearn.preprocessing import OneHotEncoder, MinMaxScaler

dataframe = pd.read_csv('train.csv')
dataframe.head()

def criarGrafico(coluna):
  plt.figure(figsize=(6, 4))
  plt.boxplot(dataframe[coluna], vert=False)

  plt.title(f'Boxplot da coluna {coluna}')
  plt.xlabel('Valor')
  plt.ylabel('')

  plt.show()

def criarInformacoesNumericas(nomeDoAtributo):
  print(f'INFORMAÇÕES SOBRE: {nomeDoAtributo}')

  atributo = dataframe[nomeDoAtributo].describe()
  valorMinimo = atributo['min']
  valorMaximo = atributo['max']
  valorMedio = atributo['mean']
  desvioPadrao = atributo['std']

  print(f'Intervalor de valores: entre {valorMinimo} e {valorMaximo}\nValor mínimo: {valorMinimo}\nValor máximo: {valorMaximo}\nValor médio: {valorMedio}\nDesvio padrao: {desvioPadrao}\n\n')

  criarGrafico(coluna=nomeDoAtributo)

  print("\nIdentificando Valores aberrantes usando Z-score")
  coluna_zscore = np.abs(zscore(dataframe[nomeDoAtributo]))
  limite_zscore = 3
  outliers = dataframe[coluna_zscore > limite_zscore]

  for indice, linha in outliers.iterrows():
    print(f"Id: {linha['PassengerId']}, Valor: {linha[nomeDoAtributo]}")

  print("=====================\n\n")

"""O método utilizado para encontrar valores aberrantes foi o z - score, que de acordo com um número setado, no caso 3, ele averigua se está distante da média, ou seja, nesse caso ele vê, se o valor dado estiver **3 desvios padrões** distante da média ele é considerado outlier."""

criarInformacoesNumericas("Pclass")
criarInformacoesNumericas("Age")
criarInformacoesNumericas("SibSp")
criarInformacoesNumericas("Parch")
criarInformacoesNumericas("Fare")

"""Para os plots de idade e classe não foram encontrados valores aberrantes, a classe realmente não existiria, por estar limitado a um intervalo de valores.


*   Sobre o fare, achamos alguns valores bem distantes da média, no intervalo entre 200-300 e um sendo até 500.
*   Sobre o Parch, os valores mais distantes sondavam 3 até 6 filhos, ou pais no caso
* E sobre o Sibsb os valores aberrantes estiveram entre 4 e 8 irmão ou cônjuges abordo do navio.

# c) Para os atributos binários, nominais e ordinais, indique quais os valores possíveis e a popularidade (distribuição de probabilidade) de cada.

Os atributos binários que iremos explorar é Survived (0 se nao morreu e 1 se morreu) e Sex (male para homem e female para mulher).
"""

def distribuicaoDeProbabilidade(atributo):
  distribuicao = dataframe[atributo].value_counts(normalize=True)
  print(distribuicao)
  print("\n\n")

distribuicaoDeProbabilidade("Sex")
distribuicaoDeProbabilidade("Survived")

"""#d) Identifique os valores ausentes (isna ou isnull), aberrantes e inconsistências."""

def valoresInconsistentes():
  valores_ausentes = dataframe.isnull().sum()

  colunas_desejadas = ['Pclass', 'Age', 'SibSp', 'Parch', 'Fare']
  dataframe_filtrado = dataframe[colunas_desejadas]

  coluna_zscore = np.abs(zscore(dataframe_filtrado))
  limite_zscore = 3
  outliers = (coluna_zscore > limite_zscore)

  quantidade_outliers = outliers.sum()

  tabela = pd.DataFrame({'Aberrantes': quantidade_outliers, 'Valores Ausentes': valores_ausentes})
  tabela['Aberrantes'] = tabela['Aberrantes'].replace(np.nan, 0)

  print(tabela)

valoresInconsistentes()

"""# e) Verifique e comente a correlação entre os atributos numéricos (corr).


"""

colunas_desejadas = ['Pclass', 'Age', 'SibSp', 'Parch', 'Fare']
dataframe_filtrado = dataframe[colunas_desejadas]

correlation_matrix = dataframe_filtrado.corr()
print(correlation_matrix)

"""A matriz de correlação é uma tabela quadrada, em que os valores na diagonal principal representam a correlação de cada atributo consigo mesmo (que é sempre 1.0). Os valores fora da diagonal principal indicam a correlação entre pares de atributos.

Você pode interpretar os valores da matriz de correlação da seguinte forma:

Valores próximos a 1.0 indicam uma correlação positiva forte.
Valores próximos a -1.0 indicam uma correlação negativa forte.
Valores próximos a 0 indicam uma correlação fraca ou nenhuma correlação.

#Limpeza de dados e transformação

#a) Preencha os valores ausentes (Tente atribuir o valor mais provável).
"""

# Para a idade, atribuirei a média nos valores faltantes
dataframe['Age'].fillna(dataframe['Age'].mean(), inplace=True)

# Como a cabin não há relacao entre os atributos la dentro, sera preenchido com a moda entre os valores
dataframe['Cabin'].fillna(dataframe['Cabin'].mode()[0], inplace=True)

# Mesmo esquema para o Embarked
dataframe['Embarked'].fillna(dataframe['Embarked'].mode()[0], inplace=True)
valoresInconsistentes()

"""#b) Suavize os ruídos (use o qcut ou cut para dividir os bins)."""

# Vou suavizar os atributos Fare, age usando a média móvel e intervalos pré definidos

def suavizarMediaMovel():
  janela = 20
  dataframe['Age'] = dataframe['Age'].rolling(window=janela, min_periods=1).mean()
  dataframe['Fare'] = dataframe['Fare'].rolling(window=janela, min_periods=1).mean()

def suavizarComIntervalo():
  binsIdade = [0, 18, 30, 50, float('inf')]
  labelsIdade = ['0-17', '18-29', '30-49', '50+']

  binsFare = [0, 50, 100, 150, 200, 300, float('inf')]
  labelsFare = ['0-50', '50-100', '100-150', '150-200', '200-300', '300+']

  dataframe['Faixa Etária'] = pd.cut(dataframe['Age'], bins=binsIdade, labels=labelsIdade, right=False)
  dataframe['Faixa Fare'] = pd.cut(dataframe['Fare'], bins=binsFare, labels=labelsFare, right=False)

suavizarMediaMovel()
# suavizarComIntervalo()
# valoresInconsistentes()
dataframe.head()

"""#     c) Resolva as inconsistências, se houver.


"""

# Verificando se há valores inconsistente na coluna 'Sex', onde deve ter apenas 'male' ou 'female'
for column in dataframe.columns:
    if column == 'Sex':
        values = dataframe[column].unique()
        for value in values:
            if value != 'male' and value != 'female':
                print(f'Valor inconsistente: {value}')

"""Após analises, constatamos que não houve inconsistências, não após remover ruídos e preencher valores faltantes

#      d) Transforme atributos categóricos nominais em um vetor numérico (por exemplo, usando o OneHotEncoder).
"""

# Aqui o que faz sentido é a Cabin, pois seria a que repete em algum possivel caso, diferente do nome e do
# ticket que são únicos

encoder = OneHotEncoder()

atributos_categoricos = ['Cabin']
atributos_encoded = encoder.fit_transform(dataframe[atributos_categoricos]).toarray()

atributos_encoded = pd.DataFrame(atributos_encoded, columns=encoder.get_feature_names_out(atributos_categoricos))

atributos_encoded.head()

"""# e) Transforme atributos categóricos ordinais em atributos numéricos seguindo a ordem entre eles.




"""

# Aqui o atributo categórico ordinal é o Embarked, esta sendo ordenado em C = 1, Q = 2 e S = 3
print(dataframe['Embarked']) 

dataframe['Embarked'] = dataframe['Embarked'].map({'C': 1, 'Q': 2, 'S': 3})  

print(dataframe['Embarked'])

"""# f) Normalize os valores de atributos numéricos.


"""

# Os atributos númericos aqui são a Idade do passageiro, a Tarifa paga por ele e o número do local de embarque
atributos_numericos = ['Age', 'Fare', 'Embarked']

scaler = MinMaxScaler()

dataframe[atributos_numericos] = scaler.fit_transform(dataframe[atributos_numericos])

print(dataframe)